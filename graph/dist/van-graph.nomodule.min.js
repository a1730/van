{const{b:t,table:e,td:n,tr:o}=van.tags;let a,r,s;const c=()=>{const t=Viz.instance(),e=van.state(0);return a=Object.entries(e).find(([t,e])=>Array.isArray(e))[0],r=Object.entries(e).filter(([t,e])=>Array.isArray(e))[1][0],van.tags.span(e),s=Object.keys(e[a][0]).find(t=>"f"!==t),t},{promise:i,resolve:l}=Promise.withResolvers();c().then(t=>l(t));const d=a=>e({border:0,cellborder:1,cellspacing:0},a.t.startsWith(f)?void 0:o(n(t(a.t))),a.o?o(n(a.o.nodeName)):void 0,a.i?o(n(`State {val: ${JSON.stringify(a.i.rawVal)}}`)):void 0,a.l?o(n(a.l.toString()+"\n")):void 0).outerHTML.replaceAll("\n",'<br align="left"/>'),f="<unnamed>_",b=Object.getPrototypeOf(van.state()),m=t=>t.filter(t=>t[s]?.isConnected),v=async(t,{rankdir:e="LR"}={})=>{let n=0;const o=()=>f+ ++n,c=new Map,l=Array();if(Array.isArray(t))for(const e of t)c.set(e,{t:o(),i:e});else for(const[e,n]of Object.entries(t))c.set(n,{t:e,i:n});let v=c.entries();for(let t=v.next();!t.done;t=v.next()){const[e,n]=t.value;if(Object.getPrototypeOf(e)===b){e[a]=m(e[a]),e[r]=m(e[r]);for(const t of e[a]){const e=t[s];let a=c.get(e);a||c.set(e,a={t:o(),l:t.f,o:e}),l.push([n,a])}for(const t of e[r]){const e=t.s;let a=c.get(e);a||c.set(e,a={t:o(),i:e}),a.l=t.f,l.push([n,a])}}}return(await i).renderSVGElement({graphAttributes:{rankdir:e},nodeAttributes:{shape:"plain",fontname:"Courier",fontsize:10},nodes:[...c.values()].map(t=>({name:t.t,attributes:{label:{html:d(t)}}})),edges:l.map(([t,e])=>({tail:t.t,head:e.t}))})};window.vanGraph={show:v}}